// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package inject

import (
	"errors"
	"fmt"
)

const (
	// AnnotationIDTypeDEFAULT is a AnnotationIDType of type DEFAULT.
	AnnotationIDTypeDEFAULT AnnotationIDType = iota
	// AnnotationIDTypeNAMED is a AnnotationIDType of type NAMED.
	AnnotationIDTypeNAMED
	// AnnotationIDTypeGROUPED is a AnnotationIDType of type GROUPED.
	AnnotationIDTypeGROUPED
)

var ErrInvalidAnnotationIDType = errors.New("not a valid AnnotationIDType")

const _AnnotationIDTypeName = "DEFAULTNAMEDGROUPED"

var _AnnotationIDTypeMap = map[AnnotationIDType]string{
	AnnotationIDTypeDEFAULT: _AnnotationIDTypeName[0:7],
	AnnotationIDTypeNAMED:   _AnnotationIDTypeName[7:12],
	AnnotationIDTypeGROUPED: _AnnotationIDTypeName[12:19],
}

// String implements the Stringer interface.
func (x AnnotationIDType) String() string {
	if str, ok := _AnnotationIDTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("AnnotationIDType(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x AnnotationIDType) IsValid() bool {
	_, ok := _AnnotationIDTypeMap[x]
	return ok
}

var _AnnotationIDTypeValue = map[string]AnnotationIDType{
	_AnnotationIDTypeName[0:7]:   AnnotationIDTypeDEFAULT,
	_AnnotationIDTypeName[7:12]:  AnnotationIDTypeNAMED,
	_AnnotationIDTypeName[12:19]: AnnotationIDTypeGROUPED,
}

// ParseAnnotationIDType attempts to convert a string to a AnnotationIDType.
func ParseAnnotationIDType(name string) (AnnotationIDType, error) {
	if x, ok := _AnnotationIDTypeValue[name]; ok {
		return x, nil
	}
	return AnnotationIDType(0), fmt.Errorf("%s is %w", name, ErrInvalidAnnotationIDType)
}

// MarshalText implements the text marshaller method.
func (x AnnotationIDType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *AnnotationIDType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseAnnotationIDType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// AnnotationTypeMODULE is a AnnotationType of type MODULE.
	AnnotationTypeMODULE AnnotationType = iota
	// AnnotationTypePROVIDE is a AnnotationType of type PROVIDE.
	AnnotationTypePROVIDE
	// AnnotationTypeINJECT is a AnnotationType of type INJECT.
	AnnotationTypeINJECT
	// AnnotationTypeINVOKE is a AnnotationType of type INVOKE.
	AnnotationTypeINVOKE
)

var ErrInvalidAnnotationType = errors.New("not a valid AnnotationType")

const _AnnotationTypeName = "MODULEPROVIDEINJECTINVOKE"

var _AnnotationTypeMap = map[AnnotationType]string{
	AnnotationTypeMODULE:  _AnnotationTypeName[0:6],
	AnnotationTypePROVIDE: _AnnotationTypeName[6:13],
	AnnotationTypeINJECT:  _AnnotationTypeName[13:19],
	AnnotationTypeINVOKE:  _AnnotationTypeName[19:25],
}

// String implements the Stringer interface.
func (x AnnotationType) String() string {
	if str, ok := _AnnotationTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("AnnotationType(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x AnnotationType) IsValid() bool {
	_, ok := _AnnotationTypeMap[x]
	return ok
}

var _AnnotationTypeValue = map[string]AnnotationType{
	_AnnotationTypeName[0:6]:   AnnotationTypeMODULE,
	_AnnotationTypeName[6:13]:  AnnotationTypePROVIDE,
	_AnnotationTypeName[13:19]: AnnotationTypeINJECT,
	_AnnotationTypeName[19:25]: AnnotationTypeINVOKE,
}

// ParseAnnotationType attempts to convert a string to a AnnotationType.
func ParseAnnotationType(name string) (AnnotationType, error) {
	if x, ok := _AnnotationTypeValue[name]; ok {
		return x, nil
	}
	return AnnotationType(0), fmt.Errorf("%s is %w", name, ErrInvalidAnnotationType)
}

// MarshalText implements the text marshaller method.
func (x AnnotationType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *AnnotationType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseAnnotationType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ModuleAttrMODULE is a ModuleAttr of type MODULE.
	ModuleAttrMODULE ModuleAttr = iota
	// ModuleAttrPATH is a ModuleAttr of type PATH.
	ModuleAttrPATH
	// ModuleAttrPACKAGE is a ModuleAttr of type PACKAGE.
	ModuleAttrPACKAGE
	// ModuleAttrFUNC is a ModuleAttr of type FUNC.
	ModuleAttrFUNC
)

var ErrInvalidModuleAttr = errors.New("not a valid ModuleAttr")

const _ModuleAttrName = "MODULEPATHPACKAGEFUNC"

var _ModuleAttrMap = map[ModuleAttr]string{
	ModuleAttrMODULE:  _ModuleAttrName[0:6],
	ModuleAttrPATH:    _ModuleAttrName[6:10],
	ModuleAttrPACKAGE: _ModuleAttrName[10:17],
	ModuleAttrFUNC:    _ModuleAttrName[17:21],
}

// String implements the Stringer interface.
func (x ModuleAttr) String() string {
	if str, ok := _ModuleAttrMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ModuleAttr(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ModuleAttr) IsValid() bool {
	_, ok := _ModuleAttrMap[x]
	return ok
}

var _ModuleAttrValue = map[string]ModuleAttr{
	_ModuleAttrName[0:6]:   ModuleAttrMODULE,
	_ModuleAttrName[6:10]:  ModuleAttrPATH,
	_ModuleAttrName[10:17]: ModuleAttrPACKAGE,
	_ModuleAttrName[17:21]: ModuleAttrFUNC,
}

// ParseModuleAttr attempts to convert a string to a ModuleAttr.
func ParseModuleAttr(name string) (ModuleAttr, error) {
	if x, ok := _ModuleAttrValue[name]; ok {
		return x, nil
	}
	return ModuleAttr(0), fmt.Errorf("%s is %w", name, ErrInvalidModuleAttr)
}

// MarshalText implements the text marshaller method.
func (x ModuleAttr) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ModuleAttr) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseModuleAttr(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
